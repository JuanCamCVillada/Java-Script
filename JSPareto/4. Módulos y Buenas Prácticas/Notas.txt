Por qu√© usar m√≥dulos en JavaScript?
Cuando un proyecto crece, el c√≥digo puede volverse dif√≠cil de mantener. En lugar de tener todo en un solo archivo, podemos dividirlo en m√≥dulos, organizando funciones y variables en archivos separados.


Beneficios de usar m√≥dulos:

- Mantiene el c√≥digo limpio y organizado.
- Permite reutilizar c√≥digo en diferentes partes del proyecto.
- Evita conflictos de nombres entre variables y funciones.


Exportar e Importar M√≥dulos: -----------------

tenemos un m√≥dulo desde otro archivo: 
//La exportamos. 
    
    // Exportar una funci√≥n

    export function saludar(nombre) {
        return `Hola, ${nombre}!`;
    }

    // Exportar una constante

    export const despedida = "¬°Adi√≥s!";

En el archivo Main: 

    // Importar la funci√≥n y la constante desde saludos.js

    import { saludar, despedida } from "./saludos.js";

    console.log(saludar("Juan"));  // "Hola, Juan!"

    console.log(despedida);  // "¬°Adi√≥s!"

-------------------------------------
Exportar e importar un m√≥dulo entero (export default)

A veces queremos exportar solo una cosa por archivo, sin necesidad de escribir su nombre exacto al importarlo.

üìå Archivo: calculadora.js:

    export default function sumar(a, b) {
        return a + b;
    }   

üìå Archivo: main.js: 

// Importar la funci√≥n por defecto (no requiere llaves {})
import sumar from "./calculadora.js";

console.log(sumar(5, 3)); // 8


export default permite importar la funci√≥n sin usar llaves {}.
El nombre del import (sumar) puede cambiarse, ya que es el √∫nico exportado por defecto.

---------------------------------

Separar la l√≥gica en funciones reutilizables

En un proyecto real, no deber√≠amos mezclar toda la l√≥gica en un solo archivo. Una buena pr√°ctica es tener archivos dedicados a cada funci√≥n importante.

üìå Ejemplo:
üü¢ operaciones.js (archivo con funciones matem√°ticas)

    export function multiplicar(a, b) {
        return a * b;
    }

    export function dividir(a, b) {
        if (b === 0) {
            throw new Error("No se puede dividir por cero.");
        }
        return a / b;
    }

üü¢ app.js (archivo principal del proyecto)

    import { multiplicar, dividir } from "./operaciones.js";

    console.log(multiplicar(4, 5)); // 20
    console.log(dividir(10, 2));    // 5
---------------------------------------

Buenas pr√°cticas en nombres de variables y funciones

Reglas b√°sicas:
‚úîÔ∏è Usa nombres descriptivos para funciones y variables.
‚úîÔ∏è Usa camelCase (nombreCompleto, calcularTotal).
‚úîÔ∏è No uses nombres muy gen√©ricos (x, dato, cosas).

---------------------------------------

 EJERCICIOS

Ejercicio 1: Crear y usar m√≥dulos
üìå Objetivo: Separar funciones en m√≥dulos y usarlas en otro archivo.

üìå Pasos:
1Ô∏è Crea un archivo utils.js con dos funciones:
mayusculas(texto): devuelve el texto en may√∫sculas.

longitud(texto): devuelve la cantidad de caracteres.

2Ô∏è Crea un archivo main.js e importa las funciones.

3Ô∏è Usa ambas funciones en console.log().

----------------------------------------

Ejercicio 2: Exportar un m√≥dulo por defecto
üìå Objetivo: Usar export default para importar una funci√≥n.

üìå Pasos:
1Ô∏è Crea un archivo numeros.js con la funci√≥n esPar(numero), que devuelve true si el n√∫mero es par.

2Ô∏è Usa export default esPar.

3Ô∏è Crea un archivo app.js, importa esPar y pru√©balo con console.log().

----------------------------------------

Ejercicio 3: Manejar errores en un m√≥dulo
üìå Objetivo: Crear un m√≥dulo que use try/catch para manejar errores.

üìå Pasos:
1Ô∏è‚É£ Crea calculos.js con la funci√≥n dividir(a, b), que maneja errores si b === 0.
2Ô∏è‚É£ Usa throw new Error("No se puede dividir por cero.") si b es 0.
3Ô∏è‚É£ Importa la funci√≥n en script.js y pru√©bala con n√∫meros v√°lidos e inv√°lidos.